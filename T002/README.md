# 数当てゲームのプログラム

* ユーザ入力を受け付け、結果を出力するためにはio（入出力）ライブラリをスコープに入れる必要がある

* prelude（プレリュード）
  * 標準ライブラリ

* 不変と可変

```rust
let apples = 5; // immutable
                // 不変
let mut bananas = 5; // mutable
                     // 可変
```

* ::newの行にある::構文はnewがString型の関連関数であることを示しています。 

* 関連関数
  * ある型（ここではString）に対して実装される関数のこと
  * 

* つまりlet mut guess = String::new();という行は可変変数を作成し、その変数は現時点では新しい空のStringのインスタンスに束縛されている

* この&は、この引数が参照であることを示し、これによりコードの複数の部分が同じデータにアクセスしても、そのデータを何度もメモリにコピーしなくて済みます

* Rustの標準ライブラリにはResultという名前の型がいくつかあります。

* もしexpectメソッドを呼び出さなかったら、コンパイルはできるものの警告が出るでしょう。

* Cargoはその依存関係が必要とするすべてについて最新のバージョンをレジストリから取得します。 レジストリとはCrates.ioのデータのコピーです。 Crates.ioは、Rustのエコシステムにいる人たちがオープンソースのRustプロジェクトを投稿し、他の人が使えるようにする場所です。

* CargoはCargo.lockファイルが存在することを確認し、バージョンを把握するすべての作業を再び行う代わりに、そこで指定されているバージョンを使います。 これにより再現性のあるビルドを自動的に行えます。 言い換えれば、Cargo.lockファイルのおかげで、あなたが明示的にアップグレードするまで、プロジェクトは0.8.3を使い続けます。

```rust
let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");
```

* Stringインスタンスのtrimメソッドは文字列の先頭と末尾の空白をすべて削除

* 文字列のparseメソッドは文字列をパース（解析）して何らかの数値にします

* しばしばエラーになるものについては、Result型でかえってくる

* expectの呼び出しからmatch式に切り替えて、エラーによるクラッシュからエラー処理へと移行します。 parseがResult型を返すことと、ResultがOkとErrの列挙子を持つ列挙型であることを思い出してください。 